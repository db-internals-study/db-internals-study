# 5장 트랜잭션 처리와 복구

- ACID:
  - Atomicity: 트랜잭션은 나눌수 없다.
  - Consistency: 제약조건을 위반하지 않고, 유효한 상태에서 유효한 상태로만 변경가능하다
  - Isolation: 트랜ㄱ잭션은 다른 트랜잭션이 존재하는지 모르고 간섭없이 수행되어야한다.
  - Duration: 트랜잭션 커밋 후 디스크에 저장된 데이터베이스의 상태는 시스템이 중단되거나 정전 또는 시스템 장애가 발생해도 그대로 유지돼야 한다.
- Lock Manager: 리소스에 대한 동시접근을 제어하고 데이터 무결성을 보장한다.
- Page Cache: 영구 저장소에 동기화되지 않은 페이지를 캐시한다.
- Log Manager: 동기화 되지 않은 페이지 캐시의 내용이 손실되지 않도록 작업 히스토리를 저장한다.

## 버퍼 관리
- 가상디스크: 메모리에 변경되지 않은 캐시된 페이지를 재사용하는 것
- 페이지케시, 버퍼 풀
- 페이징: 캐시되지 않은 페이지를 디스크에서 메모리로 복사하는 작업
- 더티페이지: 디스크로 플러시되지 않은 변경된 페이지
- 페이지 캐시의 주요기능:
  - 페이지 내용을 메모리에 캐시한다.
  - 디스크에 저장된 페이지에 대한 변경 사항을 함께 버퍼링하고 캐시된 페이지에 반영한다
  - 캐시되지 않은 데이터가 요청된 경우 메모리에 공간이 충분하다면 페이징하고 캐시된 버전을 반환한다.
  - 캐시된 페이지가 요청된 경우 메모리에서 반환한다.
  - 메모리에 새로운 페이지를 추가할 공간이 없을 경우 일부 페이지를 만료시키고 페이지로 플러시한다.
- 커널 페이지 캐시 우회 기법: O_DIRECT 플래그, fadvise(단 잘 안될수 있기에 O_DIRECT)

### 캐싱
- 페이지 캐시를 어플리케이션에 특화된 커널 페이지 캐시라고 생각할 수 있다.

### 캐시 만료
- PostgreSQL: Background flush writer
- 캐시의 필수적인 요소:
  - 디스크 접근 횟수를 줄이기 위해 플러시 시점을 늦춘다.
  - 페이지를 우선적으로 플러시해 빠르게 캐시에서 제거한다.
  - 제거할 페이지를 선택하고 최적의 순서로 플러시한다.
  - 캐시 크기를 메모리 범위 내로 유지한다.
  - 기본 저장소에 저장되는 않은 데이터는 손실되지 않아야 한다.

### 페이지 고정
- B-Tree는 상위레벨노드는 대부분의 읽기 작업에서 접근한다.
- 가까운 시간 내에 요청될 확률이 높은 페이지는 고정시킬 수 있다.
- 트리 구조 변경은 메모리에 모아두었다가 실행한다.

- 프리페치와 즉시 만료:
  - 프리페치: 요청전에 미리 페이징
  - 유지관리 프로세스에서 접근한 페이지는 일반 쿼리에서 사용할 확률이 낮기 때문에 사용후 즉시 캐시에서 만료시킨다.

### 페이지 교체 알고리즘
- 캐시된 페이지가 요청될 확률을 계산 가능해야한다.
- 만료 정책에 따라 캐시에서 제거한다.
- 페이지 교체 알고리즘은 정확한 예측보다는 불필요한 페이징을 방지하는 게 목표이다.
- 벨레이디의 모순: 적합하지 않은 페이지 교체 알고리즘을 사용했을 때 페이지 수가 증가하면 제거되는 페이지 수도 같이 증가하는 현상

#### FIFO, LRU
- 2Q LRU, LRU-K

#### CLOCK
- CLOCK-sweep

#### LFU
- 페이징 횟수 대신 페이지가 참조된 횟수를 기반으로 제거할 페이지를 선택하는 방법도 있다.
- TinyLFU

### 복구
- WAL(선행 기록 로그): 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 추가 전용 보조 자료구조:
  - 디스크에 저장된 페이지에 대한 변경 사항을 페이지 캐시에 버퍼링하는 동시에 데이터베이스 시스템 맥락에서의 지속성을 보장한다.
  - 캐시된 페이지가 디스크와 동기화될 때까지 작업 이력을 디시크에 저장한다. 데이터베이스의 상태를 변경하는 모든 작업을 실제 페이지에 적용하기 전에 먼저 디스크에 로깅한다.
  - 장애 발생 시 로그를 기반으로 마지막 메모리 상태를 재구성한다.
- fsync가 정상적으로 실행되지 않았음에도 성공했다고 착각할수 있다. 따라서 PostgreSQL 은 별도로 동기화되었는지 확인한다.

#### 로그의 시맨틱
- WAL 은 여러 로그 레코드로 구성된다. 모든 레코드에는 단조 증가하는 고유 로그 시퀀스 번호가 있다.
- 로그 레코드의 크기는 디스크 블록의 크기보다 작을 수 있기 때문에 로그 버퍼에 임시 저장하고 포스 작업시 디스크로 플러시한다.
- 포스 작업은 로그 버퍼가 가득차면 수행되거나 트랮낵션 매니저 또는 페이지 캐시가 직업 요청할 수 있다. 모든 로그 레코드는 LSN과 동일한 순서로 플러시돼야 한다.
- 트랜잭션의 커밋 레코드의 LSN까지 플러시되기 전까지는 해당 트랜잭션은 커밋된 것으로 간주할 수 없다.
- 보상 로그레코드(CLR, Compensation Log Record): 롤백 또는 복구 중 장애가 발생해도 시스템이 계속 동작할수 있도록 두는 별도의 로그
- Trimming: 체크포인트에 도착하면 이전 로그를 정리하는 작업
- 체크포인트: 해당 시점 이전의 모든 로그 레코드가 플러시됐고 더 이상 필요하지 않다는 것을 로그에 명시하는 수단
- 퍼지 체크포인트: 특별한 로그 레코드로 더티페이지에 대한 정보와 트랜잭션 테이블의 내용을 저장한다.:
  - 실행중인 트랜잭션을 중지하지 않고도 체크포인트를 만드는 방법

#### 작업 로그 대 데이터로그
- Copy-On-Write
- Shadow Paging
- 모든 상태변화는 이전 상태와 이후 상태 조합으로 나타낼수 있으며, redo와 undo 작업으로 만들수 있다.
- 물리적인 로그는 수행 전후 상태를 모두 저장하기에 영향을 받는 모든 페이지를 참조해야한다.
- 논리적 로그는 페이지에 대한 직접적인 로그가 아닌 논리적인 로그
- binlog vs redolog:
  - redolog: engine 레벨의 물리적 로그
  - binlog: sql에 대응하는 논리적인 로그

#### 스틸과 포스 정책
- 스틸
  - 스틸 정책: 수정한 페이지를 커밋하기도 전에 플러시하는 것을 허용한다.
  - 노스틸 정책: 커밋되지 않은 트랜잭션이 디스크로 플러시되는 것을 허용하지 않는다.:
    - 디스크에는 이전 상태의 페이지가 저장돼 있고 로그에는 최신 변경사항이 저장돼 있기 때문에 리두 로그만 사용해 상태를 복구할 수 있다.
    - 페이지를 더 오랫동안 캐시해야 하기 때문에 더 큰 페이지 캐시가 필욯라 수 있다.
- 포스
  - 포스 정책: 트랜잭션이 수정한 모든 페이지를 커밋 전에 플러시한다.:
    - 많은 IO로 인해 트랜잭션 커밋 시간이 증가한다.
  - 노포스 정책: 일부 페이지가 디스크로 플러시되지 않았더라도 트랜잭션 커밋을 허용한다.

#### ARIES
- 스틸/노포스 정책 기반의 복구 알고리즘이다.
- 장애 발생 후 데이터베이스 시스템을 재시작 할 때 복구 3단계:
  - 분석 단계: 페이지 캐시에 저장된 더티 페이지와 장애 발생 당시 수행중이던 트랜잭션을 파악한다. 더티 페이지에 대한 정보를 기반으로 리두 단계의 시작 지점을 결정한다. 트랜잭션 목록은 언두 단계에서 미완료된 트랜잭션을 롤백하는 데 사용한다.
  - 리두 단계: 장애가 발생하기 전까지의 작업을 재수행하고 데이터베이스를 이전상태로 복원한다. 불완전한 트랜잭션뿐만 아니라 커밋됐지만 결과가 디스크로 플러시 되지 않은 트랜잭션을 롤백하기 위한 준비 단계다.
  - 언두 단계: 불완전한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원한다. 모든 작업은 실제 수행 순서의 역순으로 롤백된다. 복구 중에도 장애가 발생할 수 있기 때문에 언두 작업도 로그에 기록해야 한다.

### 동시성 제어
- 낙관적 동시성 제어(OCC, Optimistic Concurrency Control):
  - 여러 트랜잭션이 동시에 읽고 쓰는 것을 허용하고 결합된 여러 작업이 직렬화가 가능한지 여부를 결정한다.
  - 트랜잭션이 서로 간섭하지 않고 각자의 작업 내역을 유지할 수 있게 하고 커밋 전에 충돌이 발생할 수 있는지 확인한다. 충돌이 발생할 경우 트랜잭션 중 하나를 중단한다.
- 다중 버전 동시성 제어(MVCC, Multiversion Concurrency Control):
  - 여러 버전의 레코드를 저장해 과거의 특정 타임스탬프의 데이터베이스의 일관성을 보장한다.
  - 무잠금 방식: 타임스탬프 순서화 기법
  - 잠금 방식: 2단계 잠금
- 비관적 동시성 제어(PCC, Pessimistic Concurrency Control):
  - 잠김 기반 방식: 레코드에 대한 잠금
  - 무잠금 방식: 트랜잭션의 스케줄에 따라 실행. 데드락 발생 가능

### 직렬화 가능성
- ACID와 트랜잭션 결과 정확성이 목표이다.
- 트랜잭션을 동시에 수행하면서 직렬 스케줄의 정확성과 단순성을 유지하는 방법이 목표이다.

### 트랜잭션 격리
- 격리 수준: 트랜잭션이 변경한 내용이 다른 트랜잭션에서 접근가능한지를 정의

### 읽기와 쓰기 이상현상
- 읽기 이상:
  - Dirty Read: Uncommitted Transaction 이 읽히는 현상
  - Non-repeatable Read: 하나의 트랜잭션에서 동일한 row 를 두번 쿼리했을때 결과가 다른 현상
  - Phantom Read: 트랜잭션에서 여러 로우를 두번 쿼리했을 때 결과가 다른 현상
- 쓰기 이상:
  - Lost Update: 같은 값을 수정할때, 한쪽의 수정이 사라지는 현상
  - Dirty Write: Uncommitted Transaction 을 읽어서 쓰는 현상
  - Write Skew: 트랜잭션 내에서 읽었을때는 조건을 만족하지만, 쓸때 조건을 불만족하는 경우 (e.g. Unique 무결성)

### 격리 수준
- Read uncommitted: Dirty Read, Non-repeatable Read, Phantom Read
- Read Committed: Non-repeatable Read, Phantom Read
- Repeatable read: Phantom Read
- Serializable

### 낙관적 동시성 제어
- 일반적인 트랜잭션 수행 과정:
  - 읽기 단계: 트랜잭션 존속성과 트랜잭션의 효과
  - 검증 단계: ACID 속성이 유지되는지 검증하는 단계
  - 쓰기 단계: 충돌이 발견되지 않았다면, 데이터베이스 상태로 커밋한다.

### 다중 버전 동시성 제어
- MVCC: 여러 버전의 레코드를 저장하고 단조 증가하는 트랜잭션 ID 또는 타임스탬프로 식별해 데이터베이스 트랜잭션의 일관성을 보장하는 동시성 제어방식이다.
- 커밋된 값과 커밋되지 않은 값을 구분한다.
- 스냅숏 격리다.

### 비관적 동시성 제어
- `max_read_timestamp`, `max_write_timestamp`
- Thomas Write Rule: 타임스탬프가 `max_write_timestamp` 보다 낮은 쓰기 작업이 쓴 값은 무시해도 되기 때문에 허용한다.

### 잘금 기반 동시성 제어
- 2PL(Two-Phase Locking):
  - 확장단계: 필요한 잠금은 획득하고 유지한다.
  - 축소단계: 획득한 잠금을 해제한다.

#### 교착상태(데드락)
- 교착 상태를 방지하는 방법:
  - 대기 또는 중지(Wait-Die): 자신보다 타임스탬프가 더 높은 트랜잭션만이 트랜잭션을 블록할 수 있다.
  - 선점 또는 대기(Wound-wait): 타임스탬프가 더 낮은 트랜잭션만이 트랜잭션을 블록할수 있다.

#### 잠금 & 래치
- 트랜잭션 처리에서 데이터의 논리적 무결성과 물리적 무결성을 유지하는 메커니즘은 서로 같지 않다.
- 논리적 무결성: 잠금:
  - 동시 수행 트랜잭션을 격리 및 스케줄링하고 데이터베이스의 상태를 관리하는 데 사용된다.
  - 트랜잭션이 수행되는 동안 유지된다.
- 물리적 무결성: 래치:
  - 물리적 트리 구조를 보호하며 페이지에 대해 요청할 수 있다.
  - 무잠금 동시성 제어 방식도 래치를 사용한다.
  - 동시성을 높이기 위해서는 래치를 페이지를 읽거나 업데이트하는 동안에만 가능한 최대한 짧게 유지해야한다.
  - 동시 수행 작업의 종류:
    - 동시 읽기: 여러 쓰레드가 같은 페이지를 요청하고 수정하지는 않는다.
    - 동시 업데이트: 여러 쓰레드가 같은 페이지를 수정한다.
    - 쓰기 중 읽기: 쓰레드가 페이지를 수정하는 동안 다른 페이지가 같은 페이지를 읽는다.

#### 리더-라이터 잠금
- RW Lock
- c.f. Busy wait vs Queuing

#### 래치 크래빙
- Latch Crabbing:
  - 래치는 최대한 짧게 소유하고 작업을 수행하는데 래치가 더 이상 필요하지 않을 경우 바로 해제한다.
  - 낙관적
  - 대부분의 삽입과 삭제 작업은 상위 레벨로 전파되는 구조 변경을 발생시키지 않는다고 가정한다.
  - 루트를 수정할 필요가 있으면, 루트에서부터 다시 탐색한다.

#### B^{link}-Tree
- B*-트리에 하이 키와 형제 링크 포인터를 추가한 자료구조
- 중간 분할 상태가 존재한다.:
  - 검색 키가 노드의 하이 키보다 클 경우(하이키 조건을 위반할 경우): 룩업 알고리즘은 변경중이라고 간주한다.
- 형제 링크르 통해 새로운 노드에 접근할 수 있기 때문에 부모 노드는 천천히 업데이트해도 정확성이 보장된다.

## 6장 B-트리의 변형
- 트리 구현 기법:
  - Copy-On-Write B-Tree: 인플레이스 업데이트 지원하지 않는다.
  - Lazy B-Tree: 동일한 노드에 대한 연속된 쓰기 작업의 I/O 요청 횟수를 줄이기 위해 수정 내용을 버퍼에 저장
  - FD-Tree: LSM 와 유사한 버퍼 메커니즘을 사용한다. 버퍼가 가득차면 불변 형태로 기록, 상위레벨에서 하위레벨로 전파
  - Bw-Tree: 여러 노드에 대한 쓰기 작업을 배치 단위로 처리해 비용을 낮춘다.
  - Cache-Oblivious B-Tree: 인메모리 자료구조처럼 사용한다.

### 쓰기 시 복사
- 장점: 단순함, 래치가 필요 없어 리더를 위해 동기화하지 않아도 된다.
- 단점: 더 많은 메모리가 필요하다.

#### 쓰기 시 복사 방식 구현: LMDB
- Lightning Memory-Mapped Database
- OpenLDAP 프로젝트에서 사용하는 키-값 데이터베이스
- 페이지 캐시와 선행 기록 록, 체크포인트, 컴팩선을 사용하지 않는다.
- 모든 쓰기 작업은 루트에서 시작한다.
- 이전 트리를 참조하는 읽기 작업이 끝나는 즉시 페이지를 회수하고 재사용할 수 있다.
- 업데이트 시 루트에서 리프노드까지의 경로의 모든 노드를 복사한다.
- 최신 버전과 변경 사항이 커밋될 버전이다.

### 노드 업데이트 추상화
- 메모리에 저장된 노드에 접근하는 방법:
  - 캐시된 버전에 바로 접근하는 방법:
    - 대부분 페이지 캐시가 관리하는 메모리 영역을 가리키거나 메모리 매핑을 사용한다
  - 기반 언어로 인메모리 객체를 생성하는 방법
  - 래퍼 객체를 사용하는 방법

### 지연형 B-트리
#### 와이어드 타이거
- MongoDB 기본 스토리지 엔진
- 업데이트 버퍼는 읽기 작업시 접근된다. 버퍼된 내용과 원본 디스크 페이지를 합쳐서 가장 최신 데이터를 반환한다.
- 업데이트 버퍼는 스킵리스트를 기반으로 한다.
- 와이어드타이거의 가장 큰 장점은 페이지 업데이트와 구조 변경은 백그라운드 쓰레득 ㅏ처리하기 때문에 읽기와 쓰기 작업은 다른 쓰레드가 완료될때까지 기다릴 필요가 없다.

### 지연 적응형 트리
- Lazy-Adaptive Tree (LA-Tree)
- 새로운 데이터 레코드를 삽입할 때 우선 루트 노드의 업데이트 버퍼에 저장
- 가득차면 하위 레벨 버퍼로 복사 및 이동해 공간 확보
- 계단식 버퍼

- 버퍼링 방법은 결국 추가적인 인메모리 버퍼 탐색과 원본 데이터와의 병합/조정 단계가 필요하다.

### FD-Tree
- 버퍼링은 소규모 랜덤 쓰기를 피하게 해준다.
- LSM 트리와 비슷한 방식으로 데이터를 인덱싱 한다.
- 작은 가변 헤드 트리와 여러 개의 정렬된 불변 배열로 구성된다.

#### 부분적 캐스케이딩
- Fractional Cascading
- Gap 을 최소화 하기 위해 인근 레벨의 배열을 브리지를 통해 연결해 레벨 사이에 지름길을 만든다.

#### 로그 배열

### Bw-Tree
- Write amplification
- Space amplification
- 동시성 문제와 래치 사용의 복잡성
- Buzzword-Tree
